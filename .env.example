# Temporal DSQL + Elasticsearch Configuration Example
# Copy this file to .env and update with your values

# DSQL Configuration (Public Endpoint + IAM Auth)
TEMPORAL_SQL_HOST=your-cluster-id.dsql.region.on.aws
TEMPORAL_SQL_PORT=5432
TEMPORAL_SQL_USER=admin
TEMPORAL_SQL_DATABASE=postgres
TEMPORAL_SQL_PLUGIN=dsql
TEMPORAL_SQL_PLUGIN_NAME=dsql
TEMPORAL_SQL_TLS_ENABLED=true
TEMPORAL_SQL_IAM_AUTH=true

# DSQL Connection Pool Settings
# CRITICAL: Pool must stay at max size to avoid connection creation under load
# (DSQL has 100 conn/sec cluster-wide rate limit)
# MaxIdleConns MUST equal MaxConns, MaxConnIdleTime is 0 (set in code)
TEMPORAL_SQL_MAX_CONNS=50
TEMPORAL_SQL_MAX_IDLE_CONNS=50
TEMPORAL_SQL_CONNECTION_TIMEOUT=30s
TEMPORAL_SQL_MAX_CONN_LIFETIME=55m

# Elasticsearch Configuration (Local Docker Container)
TEMPORAL_ELASTICSEARCH_HOST=elasticsearch
TEMPORAL_ELASTICSEARCH_PORT=9200
TEMPORAL_ELASTICSEARCH_SCHEME=http
TEMPORAL_ELASTICSEARCH_VERSION=v8
TEMPORAL_ELASTICSEARCH_INDEX=temporal_visibility_v1_dev

# AWS Configuration (for DSQL only)
AWS_REGION=eu-west-1
TEMPORAL_SQL_AWS_REGION=eu-west-1

# Temporal Configuration
TEMPORAL_LOG_LEVEL=info
TEMPORAL_HISTORY_SHARDS=4

# =============================================================================
# DSQL Connection Reservoir Configuration
# =============================================================================
# Reservoir mode pre-creates connections to avoid rate limit pressure under load.
# Instead of creating connections on-demand (which competes for DSQL's 100 conn/sec
# cluster-wide rate limit), the reservoir maintains a buffer of ready connections.
#
# How it works:
# 1. A background refiller continuously creates connections (respecting rate limits)
# 2. Connections are stored in a channel-based buffer (the "reservoir")
# 3. When database/sql needs a connection, it gets one instantly from the reservoir
# 4. No blocking on rate limiters in the request path
# =============================================================================

# Enable reservoir mode (default: false)
# When false, uses standard token-refreshing driver with pool warmup
# When true, uses reservoir-based connection management
DSQL_RESERVOIR_ENABLED=false

# Target number of connections to maintain in the reservoir (default: maxOpen)
# The refiller continuously works to keep the reservoir at this size.
# Should typically match your pool's maxOpen setting.
DSQL_RESERVOIR_TARGET_READY=50

# Threshold for aggressive refill mode (default: maxOpen)
# When reservoir size drops below this, the refiller uses full rate limit budget.
# Set equal to TARGET_READY for maximum responsiveness, or lower (e.g., 50% of target)
# to reduce rate limit usage during normal operation.
DSQL_RESERVOIR_LOW_WATERMARK=50

# Base lifetime for connections before they are discarded (default: 11m)
# Must be less than DSQL's 60-minute connection limit.
# 11 minutes is recommended to allow for jitter and guard window.
DSQL_RESERVOIR_BASE_LIFETIME=11m

# Random jitter added to each connection's lifetime (default: 2m)
# Prevents all connections from expiring at the same time (thundering herd).
# With base=11m and jitter=2m, actual lifetimes range from 10m to 12m.
DSQL_RESERVOIR_LIFETIME_JITTER=2m

# Time before expiry when connections are considered too old to hand out (default: 45s)
# Prevents handing out connections that might expire during a transaction.
# Should be longer than your longest expected transaction.
DSQL_RESERVOIR_GUARD_WINDOW=45s

# Timeout for initial reservoir fill at startup (default: 30s)
# Service waits for reservoir to reach low watermark before accepting requests.
# If timeout is reached, service continues with a warning (best-effort).
DSQL_RESERVOIR_INITIAL_FILL_TIMEOUT=30s

# Maximum concurrent Open() calls in the refiller (default: 8)
# Limits concurrent TCP/TLS handshakes to prevent pile-ups during burst.
DSQL_RESERVOIR_INFLIGHT_LIMIT=8

# =============================================================================
# Distributed Rate Limiting Configuration (Token Bucket)
# =============================================================================
# Coordinates connection rate limiting across all service instances using DynamoDB.
# Uses a token bucket algorithm that takes advantage of DSQL's burst capacity.
#
# DSQL limits:
# - Sustained rate: 100 connections/second
# - Burst capacity: 1,000 connections
#
# The token bucket refills at 100 tokens/sec and can hold up to 1,000 tokens.
# This allows fast initial fill using burst, then settles to 100/sec sustained.
# =============================================================================

# Enable DynamoDB-backed distributed rate limiting (default: false)
DSQL_DISTRIBUTED_RATE_LIMITER_ENABLED=false

# DynamoDB table name for rate limiting (required if enabled)
# Create table with: ./scripts/setup-rate-limiter-table.sh
DSQL_DISTRIBUTED_RATE_LIMITER_TABLE=temporal-dsql-rate-limiter

# Legacy per-second counter limit (used when token bucket is disabled)
DSQL_DISTRIBUTED_RATE_LIMITER_LIMIT=100

# Enable token bucket algorithm (recommended, default: false)
# When false, uses simple per-second counter (no burst support)
# When true, uses token bucket with burst capacity
DSQL_TOKEN_BUCKET_ENABLED=false

# Token refill rate (tokens/second, default: 100)
# Should match DSQL's sustained connection rate limit.
DSQL_TOKEN_BUCKET_RATE=100

# Maximum tokens in bucket (default: 1000)
# Should match DSQL's burst capacity.
DSQL_TOKEN_BUCKET_CAPACITY=1000

# Maximum wait time for acquiring a token (default: 30s)
DSQL_TOKEN_BUCKET_MAX_WAIT=30s

# =============================================================================
# Distributed Connection Lease Configuration (Slot Blocks)
# =============================================================================
# Coordinates global connection count across all service instances using DynamoDB.
# This ensures the cluster doesn't exceed DSQL's 10,000 max connections limit.
#
# Uses a block-based allocation strategy to avoid hot partition issues:
# - Pre-allocates blocks of connection slots (default: 100 slots per block)
# - Each service acquires one or more blocks at startup
# - Once a block is owned, connections can be created without DynamoDB calls
# - TTL-based crash recovery ensures blocks are released if a service crashes
#
# Requires DynamoDB table with:
# - Partition key: pk (String)
# - TTL attribute: ttl_epoch (Number)
# - On-demand billing recommended
# =============================================================================

# Enable DynamoDB-backed global connection count limiting (default: false)
# When enabled, the refiller acquires slot blocks before creating connections.
DSQL_DISTRIBUTED_CONN_LEASE_ENABLED=false

# DynamoDB table name for slot blocks (required if distributed leasing is enabled)
# Create table with: ./scripts/setup-conn-lease-table.sh
DSQL_DISTRIBUTED_CONN_LEASE_TABLE=temporal-dsql-conn-lease

# Maximum connections allowed cluster-wide (default: 10000)
# Should match DSQL's connection limit. Consider leaving headroom for burst capacity.
DSQL_DISTRIBUTED_CONN_LIMIT=10000

# Number of connection slots per block (default: 100)
DSQL_SLOT_BLOCK_SIZE=100

# Total number of blocks (default: 100, giving 100 Ã— 100 = 10,000 total slots)
DSQL_SLOT_BLOCK_COUNT=100

# TTL for crash recovery (default: 3m)
# Blocks become available after TTL expires if a service crashes.
DSQL_SLOT_BLOCK_TTL=3m

# How often to renew TTL on owned blocks (default: 1m)
DSQL_SLOT_BLOCK_RENEW_INTERVAL=1m

# Docker Configuration
TEMPORAL_IMAGE=temporal-dsql-runtime:test