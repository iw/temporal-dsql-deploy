# Dynamic configuration for Aurora DSQL development environment

# =============================================================================
# Eager Execution Settings
# =============================================================================

# Enable eager activity execution - activities can be dispatched back to the
# same worker that completed the workflow task, bypassing the server round-trip
# Required for SDK's DisableEagerActivities=false to have effect
# Default: false (must be explicitly enabled)
system.enableActivityEagerExecution:
  - value: true
    constraints: {}

# Eager workflow start is enabled by default (true)
# Allows first workflow task to be returned inline with StartWorkflowExecution response

# =============================================================================
# DSQL-Specific Settings
# =============================================================================

# Advanced Visibility settings - CRITICAL for Elasticsearch integration
system.enableReadFromClosedExecutionV2:
  - value: true
    constraints: {}

system.advancedVisibilityWritingMode:
  - value: "on"
    constraints: {}

system.enableReadVisibilityFromES:
  - value: true
    constraints: {}

system.enableLogCustomerQueryParameter:
  - value: true
    constraints: {}

# DSQL optimizations - higher QPS for 512 shards
history.persistenceMaxQPS:
  - value: 6000
    constraints: {}

matching.persistenceMaxQPS:
  - value: 6000
    constraints: {}

frontend.persistenceMaxQPS:
  - value: 6000
    constraints: {}

# DSQL connection settings
# CRITICAL: MaxIdleConns MUST equal MaxConns to prevent pool decay
# MaxConnIdleTime is set to 0 in code to prevent idle connection closure
persistence.maxConns:
  - value: 50
    constraints: {}

persistence.maxIdleConns:
  - value: 50
    constraints: {}

# DSQL transaction retry settings (due to optimistic concurrency control)
persistence.transactionSizeLimit:
  - value: 4000000
    constraints: {}

# Buffered events settings (for ID generation)
history.maxBufferedQueryCount:
  - value: 1000
    constraints: {}

# Task processing settings optimized for DSQL
matching.numTaskqueueReadPartitions:
  - value: 8
    constraints: {}

matching.numTaskqueueWritePartitions:
  - value: 8
    constraints: {}

# Matching service throughput settings
matching.maxTaskBatchSize:
  - value: 100
    constraints: {}

matching.getTasksBatchSize:
  - value: 1000
    constraints: {}

matching.longPollExpirationInterval:
  - value: 60s
    constraints: {}

# History service settings
history.timerProcessorMaxPollRPS:
  - value: 20
    constraints: {}

history.timerProcessorUpdateAckInterval:
  - value: 30s
    constraints: {}

# Visibility settings (if using DSQL for visibility)
visibility.maxPageSize:
  - value: 1000
    constraints: {}

# Cluster membership settings
system.membershipMaxJoinDuration:
  - value: 30s
    constraints: {}

# Archival settings
archival.history.enableRead:
  - value: true
    constraints: {}

archival.visibility.enableRead:
  - value: true
    constraints: {}

# Namespace settings
system.enableNamespaceNotActiveAutoForwarding:
  - value: true
    constraints: {}

# Worker settings
worker.enableLogging:
  - value: true
    constraints: {}

# Frontend settings
frontend.enableClientVersionCheck:
  - value: true
    constraints: {}

# Matching settings
matching.enableTaskInfoLogByDomainID:
  - value: false
    constraints: {}

# System settings
system.enableParentClosePolicy:
  - value: true
    constraints: {}

# DSQL-specific retry and timeout settings
persistence.defaultActivityRetryPolicy:
  - value:
      InitialIntervalInSeconds: 1
      MaximumIntervalInSeconds: 100
      BackoffCoefficient: 2.0
      MaximumAttempts: 0
    constraints: {}

# DSQL connection health check
persistence.healthCheckInterval:
  - value: 30s
    constraints: {}

# =============================================================================
# CHASM Settings (V2 Scheduler / Standalone Activities)
# =============================================================================

# Master switch — use real CHASM tree instead of noop
# Required for CHASM schedulers, standalone activities, and CHASM callbacks
history.enableChasm:
  - value: true
    constraints: {}

# Create new schedules using CHASM (V2) engine
# When false, new schedules use the workflow-backed (V1) implementation
history.enableCHASMSchedulerCreation:
  - value: true
    constraints: {}

# Enable CHASM callbacks — required for CHASM scheduler to start workflows
# Without this, schedule timer fires but StartWorkflow fails with
# "attaching workflow callbacks is disabled for this namespace"
history.enableCHASMCallbacks:
  - value: true
    constraints: {}

# Allow the chasm-scheduler experiment header from clients
# Clients can opt-in per-request via: temporal-experiment: chasm-scheduler
frontend.allowedExperiments:
  - value:
      - "chasm-scheduler"
    constraints: {}

# Nexus settings
# system.enableNexus MUST be true for CHASM scheduler — the frontend's
# validateWorkflowCompletionCallbacks checks this before allowing callbacks
# on StartWorkflow. Without it the CHASM scheduler cannot start workflows.
# The endpoint registry is kept off to reduce DSQL query noise.
system.enableNexus:
  - value: true
    constraints: {}

# Disable Nexus endpoint registry to prevent extra DSQL queries
system.nexusEndpointRegistryEnabled:
  - value: false
    constraints: {}