services:
  # Elasticsearch for visibility store
  elasticsearch:
    container_name: temporal-elasticsearch
    platform: linux/arm64
    image: elasticsearch:8.11.0
    environment:
      - cluster.routing.allocation.disk.threshold_enabled=true
      - cluster.routing.allocation.disk.watermark.low=512mb
      - cluster.routing.allocation.disk.watermark.high=256mb
      - cluster.routing.allocation.disk.watermark.flood_stage=128mb
      - discovery.type=single-node
      - ES_JAVA_OPTS=-Xms256m -Xmx256m
      - xpack.security.enabled=false
    ports:
      - "9200:9200"
      - "9300:9300"
    volumes:
      - elasticsearch-data:/usr/share/elasticsearch/data
    networks:
      - temporal-network
    cap_add:
      - IPC_LOCK
    ulimits:
      memlock:
        soft: -1
        hard: -1
      nofile:
        soft: 65536
        hard: 65536
    healthcheck:
      test: ["CMD-SHELL", "curl -sf 'http://localhost:9200/_cluster/health?wait_for_status=yellow&timeout=5s' >/dev/null || exit 1"]
      interval: 5s
      timeout: 5s
      retries: 60
      start_period: 30s
    restart: unless-stopped

  # History service - starts after elasticsearch is ready
  temporal-history:
    container_name: temporal-dsql-history
    hostname: temporal-history
    platform: linux/arm64
    image: temporal-dsql-runtime:test
    depends_on:
      elasticsearch:
        condition: service_healthy
    command:
      ["--config-file", "/etc/temporal/config/persistence-dsql.yaml", "--allow-no-auth", "start", "--service", "history"]
    env_file:
      - .env
    volumes:
      - ~/.aws:/home/temporal/.aws:ro
      - ./dynamicconfig:/etc/temporal/config/dynamicconfig:ro
      - ./docker/config/persistence-dsql-elasticsearch.template.yaml:/etc/temporal/config/persistence-dsql-elasticsearch.template.yaml:ro
    environment:
      - AWS_EC2_METADATA_DISABLED=true
      - TEMPORAL_PERSISTENCE_TEMPLATE=/etc/temporal/config/persistence-dsql-elasticsearch.template.yaml
      # Fast iteration testing - short token duration (2 min) to test token refresh
      - DSQL_TOKEN_DURATION=2m
      # Disable staggered startup for faster local testing
      - DSQL_STAGGERED_STARTUP=false
    ports:
      - "7234:7234" # gRPC
      - "6934:6934" # Membership
    expose:
      - "9090" # Prometheus metrics (internal only)
    networks:
      - temporal-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "nc -z temporal-dsql-history 7234 || nc -z $$(hostname -i) 7234"]
      interval: 10s
      timeout: 5s
      retries: 30
      start_period: 60s

  # Matching service - depends on history and elasticsearch
  temporal-matching:
    container_name: temporal-dsql-matching
    hostname: temporal-matching
    platform: linux/arm64
    image: temporal-dsql-runtime:test
    depends_on:
      elasticsearch:
        condition: service_healthy
      temporal-history:
        condition: service_healthy
    command:
      ["--config-file", "/etc/temporal/config/persistence-dsql.yaml", "--allow-no-auth", "start", "--service", "matching"]
    env_file:
      - .env
    volumes:
      - ~/.aws:/home/temporal/.aws:ro
      - ./dynamicconfig:/etc/temporal/config/dynamicconfig:ro
      - ./docker/config/persistence-dsql-elasticsearch.template.yaml:/etc/temporal/config/persistence-dsql-elasticsearch.template.yaml:ro
    environment:
      - AWS_EC2_METADATA_DISABLED=true
      - TEMPORAL_PERSISTENCE_TEMPLATE=/etc/temporal/config/persistence-dsql-elasticsearch.template.yaml
      # Fast iteration testing - short token duration (2 min) to test token refresh
      - DSQL_TOKEN_DURATION=2m
      # Disable staggered startup for faster local testing
      - DSQL_STAGGERED_STARTUP=false
    ports:
      - "7235:7235" # gRPC
      - "6935:6935" # Membership
    expose:
      - "9090" # Prometheus metrics (internal only)
    networks:
      - temporal-network
    restart: unless-stopped

  # Frontend service - depends on history + matching + elasticsearch
  temporal-frontend:
    container_name: temporal-dsql-frontend
    hostname: temporal-frontend
    platform: linux/arm64
    image: temporal-dsql-runtime:test
    depends_on:
      elasticsearch:
        condition: service_healthy
      temporal-history:
        condition: service_healthy
      temporal-matching:
        condition: service_started
    command:
      ["--config-file", "/etc/temporal/config/persistence-dsql.yaml", "--allow-no-auth", "start", "--service", "frontend"]
    env_file:
      - .env
    volumes:
      - ~/.aws:/home/temporal/.aws:ro
      - ./dynamicconfig:/etc/temporal/config/dynamicconfig:ro
      - ./docker/config/persistence-dsql-elasticsearch.template.yaml:/etc/temporal/config/persistence-dsql-elasticsearch.template.yaml:ro
    environment:
      - AWS_EC2_METADATA_DISABLED=true
      - TEMPORAL_PERSISTENCE_TEMPLATE=/etc/temporal/config/persistence-dsql-elasticsearch.template.yaml
      # Fast iteration testing - short token duration (2 min) to test token refresh
      - DSQL_TOKEN_DURATION=2m
      # Disable staggered startup for faster local testing
      - DSQL_STAGGERED_STARTUP=false
    ports:
      - "7233:7233" # gRPC
      - "8233:8233" # HTTP
      - "6933:6933" # Membership
    expose:
      - "9090" # Prometheus metrics (internal only)
    networks:
      - temporal-network
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "nc -z temporal-dsql-frontend 7233 || nc -z $$(hostname -i) 7233"]
      interval: 10s
      timeout: 5s
      retries: 30
      start_period: 60s

  # Worker service - depends on frontend + history + elasticsearch
  temporal-worker:
    container_name: temporal-dsql-worker
    hostname: temporal-worker
    platform: linux/arm64
    image: temporal-dsql-runtime:test
    depends_on:
      elasticsearch:
        condition: service_healthy
      temporal-history:
        condition: service_healthy
      temporal-frontend:
        condition: service_healthy
    command:
      ["--config-file", "/etc/temporal/config/persistence-dsql.yaml", "--allow-no-auth", "start", "--service", "worker"]
    env_file:
      - .env
    volumes:
      - ~/.aws:/home/temporal/.aws:ro
      - ./dynamicconfig:/etc/temporal/config/dynamicconfig:ro
      - ./docker/config/persistence-dsql-elasticsearch.template.yaml:/etc/temporal/config/persistence-dsql-elasticsearch.template.yaml:ro
    environment:
      - AWS_EC2_METADATA_DISABLED=true
      - TEMPORAL_PERSISTENCE_TEMPLATE=/etc/temporal/config/persistence-dsql-elasticsearch.template.yaml
      # Fast iteration testing - short token duration (2 min) to test token refresh
      - DSQL_TOKEN_DURATION=2m
      # Disable staggered startup for faster local testing
      - DSQL_STAGGERED_STARTUP=false
    ports:
      - "7239:7239" # gRPC (worker service port)
      - "6939:6939" # Membership
    expose:
      - "9090" # Prometheus metrics (internal only)
    networks:
      - temporal-network
    restart: unless-stopped

  # Temporal UI
  temporal-ui:
    container_name: temporal-dsql-ui
    platform: linux/arm64
    image: temporalio/ui:latest
    depends_on:
      temporal-frontend:
        condition: service_healthy
    environment:
      - TEMPORAL_ADDRESS=temporal-frontend:7233
      - TEMPORAL_CORS_ORIGINS=http://localhost:8080
    ports:
      - "8080:8080"
    networks:
      - temporal-network
    restart: unless-stopped

  # Mimir for metrics storage (lightweight Prometheus-compatible TSDB)
  mimir:
    container_name: temporal-mimir
    platform: linux/arm64
    image: grafana/mimir:latest
    command:
      - --config.file=/etc/mimir/mimir.yaml
    volumes:
      - ./docker/config/mimir.yaml:/etc/mimir/mimir.yaml:ro
      - mimir-data:/data
    ports:
      - "9009:9009"
    networks:
      - temporal-network
    restart: unless-stopped

  # Grafana Alloy for metrics collection (scrapes Temporal services)
  alloy:
    container_name: temporal-alloy
    platform: linux/arm64
    image: grafana/alloy:latest
    command:
      - run
      - /etc/alloy/config.alloy
      - --server.http.listen-addr=0.0.0.0:12345
    volumes:
      - ./docker/config/alloy-config.alloy:/etc/alloy/config.alloy:ro
    ports:
      - "12345:12345"
    networks:
      - temporal-network
    depends_on:
      - mimir
      - temporal-history
      - temporal-matching
      - temporal-frontend
      - temporal-worker
    restart: unless-stopped

  # Grafana for dashboards and visualization
  grafana:
    container_name: temporal-grafana
    platform: linux/arm64
    image: grafana/grafana:latest
    environment:
      - GF_SECURITY_ADMIN_USER=admin
      - GF_SECURITY_ADMIN_PASSWORD=admin
      - GF_AUTH_ANONYMOUS_ENABLED=true
      - GF_AUTH_ANONYMOUS_ORG_ROLE=Viewer
      # AWS credentials for CloudWatch datasource (uses default credential chain)
      - AWS_REGION=${AWS_REGION:-us-east-1}
      # Uncomment to use explicit credentials (not recommended for production)
      # - AWS_ACCESS_KEY_ID=${AWS_ACCESS_KEY_ID}
      # - AWS_SECRET_ACCESS_KEY=${AWS_SECRET_ACCESS_KEY}
    volumes:
      - ./docker/config/grafana-datasources.yaml:/etc/grafana/provisioning/datasources/datasources.yaml:ro
      - ./docker/config/grafana-dashboards.yaml:/etc/grafana/provisioning/dashboards/dashboards.yaml:ro
      - ./grafana:/var/lib/grafana/dashboards:ro
      - grafana-data:/var/lib/grafana
      # Mount AWS credentials for CloudWatch access
      - ~/.aws:/usr/share/grafana/.aws:ro
    ports:
      - "3000:3000"
    networks:
      - temporal-network
    depends_on:
      - mimir
    restart: unless-stopped

volumes:
  elasticsearch-data:
    driver: local
  mimir-data:
    driver: local
  grafana-data:
    driver: local

networks:
  temporal-network:
    driver: bridge